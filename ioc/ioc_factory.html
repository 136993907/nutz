<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head><meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8"/>
<title>工厂方法</title><link href="../zdoc.css" rel="stylesheet" type="text/css"/>
</head>
<body><a name="top"></a>
<div class="zdoc_header">工厂方法</div>
<div class="zdoc_author"><em>By:</em><b>wendal</b><a href="mailto:wendal1985@gmail.com">&lt;wendal1985@gmail.com&gt;</a></div>
<div class="zdoc_body">
<ul class="zdoc_index_table">
<li>
<div><span class="num">1</span><a href="#什么是工厂方法?">什么是工厂方法?</a></div>
</li>
<li>
<div><span class="num">2</span><a href="#使用Iocbean的factory">使用Iocbean的factory</a></div>
</li>
<li>
<div><span class="num">3</span><a href="#使用IocBean实例方法">使用IocBean实例方法</a></div>
</li>
</ul>
<div class="hr"><b></b></div>
<h1><a name="什么是工厂方法?"></a>什么是工厂方法?</h1>
<div style="float:right;"><a href="#top">Top</a></div>
<p>工厂方法,就是通过一个"虚拟"构造方法,供调用者获取特定的实例. 至于返回的是什么实例, 得看环境和传入的参数,及方法内的业务逻辑了.</p>
<p>例如, 希望在生产环境用Product目录下的配置文件,开发环境用dev目录下的配置文件</p>
<div class="hr"><b></b></div>
<h1><a name="使用Iocbean的factory"></a>使用Iocbean的factory</h1>
<div style="float:right;"><a href="#top">Top</a></div>
<p>通过IocBean注解内的factory参数,可以自定义工厂类及工厂method</p>
<p>factory参数的规则是, 以井号分隔,井号之前的是类名或ioc bean名称, 后面是方法名称.</p>
<pre>@IocBean(factory="net.wendal.mqtt.MqttAbcServiceFactory<span class="zdoc_code_cmt">#create", args={"refer:dao"})
</span>public class AbcService extends Service {
	...
	
}

<span class="zdoc_code_cmt">// 无任何注解
</span>public class MqttAbcServiceFactory {
	public static AbcService create(Dao dao) {
		return new XXXXAbcService(dao);
	}
}
</pre>
<p>通过其他bean生成此bean, 区别就是用$对象名称 代替 上一个例子的类名</p>
<pre>@IocBean(factory="$snakerConfigure<span class="zdoc_code_cmt">#build")
</span>public class SnakerService{}


@IocBean(name="snakerConfigure")
public class SnakerConfigure {
	public SnakerService build() {
		return ....;
	}
}
</pre>
<div class="hr"><b></b></div>
<h1><a name="使用IocBean实例方法"></a>使用IocBean实例方法</h1>
<div style="float:right;"><a href="#top">Top</a></div>
<p>先看示例. 这个功能是1.r.62新增.</p>
<p>相比@IocBean的factory参数, 这种方式是声明"其他"bean的生成, 而不是自身.</p>
<pre>@IocBean <span class="zdoc_code_cmt">// 首先,它自己必须加@IocBean, 可以使用@IocBean/@Inject的全部功能.
</span>public class MyBeanFactory {

<span class="zdoc_code_cmt">//@Inject
</span><span class="zdoc_code_cmt">//public PropertiesProxy conf; // 像普通对象那么注入任何你需要的东西,这个conf也可是其他IocBean类,但不能是这个类了,否则死循环了
</span>@IocBean
public PropertiesProxy getConf() {
    if ("product".equals(System.getProperty("nutz.runmode"))) {
          return new PropertiesProxy("/etc/nutz/custom");
    } else {
    	return new PropertiesProxy("custom/");
    }
}

<span class="zdoc_code_cmt">// 生成一个名为dataSource的bean. 命名规则是: IocBean(name=XXX) &gt; 方法名去掉get/build后首字母小写.
</span>@IocBean
public SimpleDataSource getDataSource(PropertiesProxy conf) {
    SimpleDataSource ds = new SimpleDataSource();
    ds.setJdbcUrl(conf.get("db.url", "jdbc:h2:mem:nutztest"));
    return ds;
}

@IocBean 
public Dao buildDao(DataSource dataSource) { <span class="zdoc_code_cmt">// 带参数, 默认是按类型注入
</span>    return new NutDao(dataSource);
}


@IocBean(name="dao2") <span class="zdoc_code_cmt">// 自定义bean的名字,这样方法名就随便起了
</span>public Dao xxxgetDao2(DataSource dataSource) {
    return new NutDao(dataSource);
}


@IocBean(name="dao3")
public Dao xxyyy(@Inject("refer:dataSource")DataSource ds) { <span class="zdoc_code_cmt">// 参数加@Inject,可以像属性加上@Inject一样注入值
</span>    return new NutDao(ds);
}

@IocBean(name="dao3", create="init", depose="depose") <span class="zdoc_code_cmt">// 事件也是支持的
</span>public UserService makeUserService(Dao dao) {
    return new UserServiceImpl(dao);
}
}
</pre>
<p>优缺点</p>
<ul type="disc">
<li>可以完全不使用js进行ioc配置</li>
<li>可以更灵活地根据配置信息生成对象</li>
<li>通过这种方式生成的对象,暂不支持Aop注入</li>
</ul>
</div>
<div class="zdoc_footer"><em>By:</em><b>wendal</b><a href="mailto:wendal1985@gmail.com">&lt;wendal1985@gmail.com&gt;</a></div>
</body>
</html>